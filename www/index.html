<!DOCTYPE html>
<html>
<head>
    <title>Tello Video Stream + MoveNet Offline</title>
    <style>
        html, body {
            background-color: #111;
            text-align: center;
            margin: 0;
            padding: 0;
        }

        body {
            display: flex;
            flex-directionw: column;
            align-content: center;
            align-items: center;
            justify-content: center;
        }

        #canvas-container {
            position: relative;
            margin: 0 auto;
            width: 100%;

        }

        #video-canvas, #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #video-canvas {
            z-index: 1;
            background: black;
        }

        #overlay-canvas {
            z-index: 2;
            pointer-events: none;
        }

        #status {
            color: #0f0;
            font-family: monospace;
            padding: 10px;
        }
    </style>
</head>
<body>
<div id="status">Initializing...</div>
<div id="canvas-container">
    <canvas id="video-canvas"></canvas>
    <canvas id="overlay-canvas"></canvas>
</div>

<script src="/libs/tf.min.js"></script>
<script src="/libs/tfjs-backend-webgl.min.js"></script>
<script src="/libs/pose-detection.min.js"></script>
<script src="/jsmpeg.min.js"></script>

<script>
    const statusDiv = document.getElementById('status');

    // --- Video canvas (JSMpeg uses WebGL) ---
    const canvas = document.getElementById('video-canvas');
    // --- Overlay canvas (for drawing poses) ---
    const overlayCanvas = document.getElementById('overlay-canvas');
    const url = 'ws://' + document.location.hostname + ':3001/';

    let player;
    try {
        player = new JSMpeg.Player(url, {
            canvas: canvas,
            onSourceEstablished: () => {
                statusDiv.textContent = '✅ Video connected';
                console.log('Video stream established');

                // Match overlay canvas size to video canvas
                overlayCanvas.width = canvas.width;
                overlayCanvas.height = canvas.height;
                console.log('Canvas size:', canvas.width, 'x', canvas.height);
            }
        });
    } catch (e) {
        statusDiv.textContent = '❌ JSMpeg error: ' + e.message;
        console.error(e);
    }

    // --- Initialize MoveNet ---
    let detector;
    let isDetecting = false;

    async function initMoveNet() {
        try {
            statusDiv.textContent = 'Loading TensorFlow...';
            await tf.setBackend('webgl');
            await tf.ready();

            statusDiv.textContent = 'Loading MoveNet model...';

            detector = await poseDetection.createDetector(
                poseDetection.SupportedModels.MoveNet,
                {
                    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                    modelUrl: '/models/movenet/model.json'
                }
            );

            console.log("MoveNet loaded successfully");
            statusDiv.textContent = '✅ MoveNet ready - detecting poses';
            isDetecting = true;
            requestAnimationFrame(detectPose);

        } catch (error) {
            console.error('MoveNet initialization error:', error);
            statusDiv.textContent = '❌ Error: ' + error.message;
        }
    }

    // --- Pose detection ---
    async function detectPose() {
        if (!detector || !isDetecting) return;

        try {
            // Check if canvas has content
            if (canvas.width === 0 || canvas.height === 0) {
                requestAnimationFrame(detectPose);
                return;
            }

            // Sync overlay canvas size if video size changed
            if (overlayCanvas.width !== canvas.width || overlayCanvas.height !== canvas.height) {
                overlayCanvas.width = canvas.width;
                overlayCanvas.height = canvas.height;
            }

            const input = tf.browser.fromPixels(canvas);
            const poses = await detector.estimatePoses(input);
            tf.dispose(input);

            drawPoses(poses);

        } catch (error) {
            console.error('Pose detection error:', error);
            isDetecting = false; // Stop on error to prevent spam
        }

        requestAnimationFrame(detectPose);
    }

    // --- Draw keypoints ---
    function drawPoses(poses) {
        const ctx = overlayCanvas.getContext('2d');

        if (!ctx) {
            console.error('Failed to get 2D context from overlay canvas');
            return;
        }

        // Clear previous frame
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        ctx.lineWidth = 3;
        ctx.fillStyle = 'red';

        poses.forEach(pose => {
            if (!pose.keypoints) return;

            // Draw connections between keypoints
            const connections = [
                [5, 7], [7, 9],   // Left arm
                [6, 8], [8, 10],  // Right arm
                [5, 6],           // Shoulders
                [5, 11], [6, 12], // Torso
                [11, 12],         // Hips
                [11, 13], [13, 15], // Left leg
                [12, 14], [14, 16]  // Right leg
            ];

            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 3;
            connections.forEach(([i, j]) => {
                const kp1 = pose.keypoints[i];
                const kp2 = pose.keypoints[j];
                if (kp1 && kp2 && kp1.score > 0.3 && kp2.score > 0.3) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x, kp1.y);
                    ctx.lineTo(kp2.x, kp2.y);
                    ctx.stroke();
                }
            });

            // Draw keypoints
            ctx.fillStyle = 'red';
            pose.keypoints.forEach(kp => {
                if (kp.score > 0.3) {
                    ctx.beginPath();
                    ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        });
    }

    window.addEventListener('DOMContentLoaded', initMoveNet);
</script>
</body>
</html>