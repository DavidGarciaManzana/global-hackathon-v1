<!DOCTYPE html>
<html>
<head>
    <title style="margin-bottom: 16px">Tello Video Stream + MoveNet Offline</title>
    <style>
        html, body {
            background-color: #111;
            text-align: center;
            margin: 0;
            padding: 0;
        }

        body {
            /*display: flex;*/
            /*flex-direction: column; !* fixed typo *!*/
            /*align-content: center;*/
            /*align-items: center;*/
            /*justify-content: center;*/
        }

        #wrapper {

        }

        #canvas-container {
        }

        #video-canvas, #overlay-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-height: 80vh;
        }

        #video-canvas {
            z-index: 1;
            background: black;
        }

        #overlay-canvas {
            z-index: 2;
            pointer-events: none;
        }

        #status {
            color: #0f0;
            font-family: monospace;
            padding: 10px;
        }
    </style>
</head>
<body>
<div id="wrapper">
    <div id="status">Initializing...</div>
    <div id="canvas-container">
        <canvas id="video-canvas"></canvas>
        <canvas id="overlay-canvas"></canvas>
    </div>

    <script src="/libs/tf.min.js"></script>
    <script src="/libs/tfjs-backend-webgl.min.js"></script>
    <script src="/libs/pose-detection.min.js"></script>
    <script src="/jsmpeg.min.js"></script>

    <script>
        const statusDiv = document.getElementById('status');

        // --- Video canvas (JSMpeg uses WebGL) ---
        const canvas = document.getElementById('video-canvas');
        // --- Overlay canvas (for drawing poses) ---
        const overlayCanvas = document.getElementById('overlay-canvas');
        const url = 'ws://' + document.location.hostname + ':3001/';

        let player;
        try {
            player = new JSMpeg.Player(url, {
                canvas: canvas,
                onSourceEstablished: () => {
                    statusDiv.textContent = '✅ Video connected';
                    console.log('Video stream established');

                    // Match overlay canvas size to video canvas
                    overlayCanvas.width = canvas.width;
                    overlayCanvas.height = canvas.height;
                    console.log('Canvas size:', canvas.width, 'x', canvas.height);
                }
            });
        } catch (e) {
            statusDiv.textContent = '❌ JSMpeg error: ' + e.message;
            console.error(e);
        }

        // --- Initialize MoveNet ---
        let detector;
        let isDetecting = false;

        async function initMoveNet() {
            try {
                statusDiv.textContent = 'Loading TensorFlow...';
                await tf.setBackend('webgl');
                await tf.ready();

                statusDiv.textContent = 'Loading MoveNet model...';

                detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet,
                    {
                        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                        modelUrl: '/models/movenet/model.json'
                    }
                );

                console.log("MoveNet loaded successfully");
                statusDiv.textContent = 'MoveNet ready - detecting poses';
                isDetecting = true;
                requestAnimationFrame(detectPose);

            } catch (error) {
                console.error('MoveNet initialization error:', error);
                statusDiv.textContent = '❌ Error: ' + error.message;
            }
        }

        // --- Pose detection ---
        async function detectPose() {
            if (!detector || !isDetecting) return;

            try {
                if (canvas.width === 0 || canvas.height === 0) {
                    requestAnimationFrame(detectPose);
                    return;
                }

                if (overlayCanvas.width !== canvas.width || overlayCanvas.height !== canvas.height) {
                    overlayCanvas.width = canvas.width;
                    overlayCanvas.height = canvas.height;
                }

                const input = tf.browser.fromPixels(canvas);
                const poses = await detector.estimatePoses(input);
                tf.dispose(input);

                drawPoses(poses);

            } catch (error) {
                console.error('Pose detection error:', error);
                isDetecting = false;
            }

            requestAnimationFrame(detectPose);
        }

        // --- Draw keypoints ---
        function drawPoses(poses) {
            const ctx = overlayCanvas.getContext('2d');

            if (!ctx) {
                console.error('Failed to get 2D context from overlay canvas');
                return;
            }

            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            poses.forEach(pose => {
                if (!pose.keypoints) return;

                // Draw connections
                const connections = [
                    [5, 7], [7, 9],    // Left arm
                    [6, 8], [8, 10],   // Right arm
                    [5, 6],            // Shoulders
                    [5, 11], [6, 12],  // Torso
                    [11, 12],          // Hips
                    [11, 13], [13, 15],// Left leg
                    [12, 14], [14, 16] // Right leg
                ];

                ctx.strokeStyle = 'lime';
                ctx.lineWidth = 3;
                connections.forEach(([i, j]) => {
                    const kp1 = pose.keypoints[i];
                    const kp2 = pose.keypoints[j];
                    if (kp1 && kp2 && kp1.score > 0.3 && kp2.score > 0.3) {
                        ctx.beginPath();
                        ctx.moveTo(kp1.x, kp1.y);
                        ctx.lineTo(kp2.x, kp2.y);
                        ctx.stroke();
                    }
                });

                // Draw keypoints
                ctx.fillStyle = 'red';
                pose.keypoints.forEach(kp => {
                    if (kp.score > 0.3) {
                        ctx.beginPath();
                        ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });

                if (poses.length > 0) {
                    const pose = poses[0];
                    const state = classifyPose(pose.keypoints);

                    ctx.font = "28px monospace";
                    ctx.fillStyle = "#0f0";
                    ctx.fillText(`State: ${state}`, 20, 40);

                    statusDiv.textContent = ` MoveNet ready`;
                }
            });
        }

        // --- Improved pose classification ---
        function classifyPose(keypoints) {
            const getAvgPoint = (names) => {
                const points = names.map(name => keypoints.find(k => k.name === name)).filter(Boolean);
                if (points.length === 0) return null;
                return {
                    x: points.reduce((sum, p) => sum + p.x, 0) / points.length,
                    y: points.reduce((sum, p) => sum + p.y, 0) / points.length,
                };
            };

            const hip = getAvgPoint(['left_hip', 'right_hip']);
            const knee = getAvgPoint(['left_knee', 'right_knee']);
            const ankle = getAvgPoint(['left_ankle', 'right_ankle']);
            const shoulder = getAvgPoint(['left_shoulder', 'right_shoulder']);

            if (!hip || !knee || !ankle || !shoulder) return "Unknown";

            const angle = (a, b, c) => {
                const ab = {x: a.x - b.x, y: a.y - b.y};
                const cb = {x: c.x - b.x, y: c.y - b.y};
                const dot = ab.x * cb.x + ab.y * cb.y;
                const magAB = Math.hypot(ab.x, ab.y);
                const magCB = Math.hypot(cb.x, cb.y);
                const cosine = dot / (magAB * magCB);
                return Math.acos(Math.min(Math.max(cosine, -1), 1)) * (180 / Math.PI);
            };

            const kneeAngle = angle(hip, knee, ankle);
            const trunkAngle = Math.abs(Math.atan2(shoulder.y - hip.y, shoulder.x - hip.x) * 180 / Math.PI);
            const hipY = hip.y, kneeY = knee.y, shoulderY = shoulder.y;

            // Adjusted heuristics
            if (Math.abs(shoulderY - hipY) < 50) {
                return "Lying";
            } else if (kneeAngle > 160 && hipY + 30 < kneeY) {
                return "Standing";
            } else if (kneeAngle < 140 && trunkAngle > 50) {
                return "Sitting";
            } else {
                return "...";
            }
        }

        window.addEventListener('DOMContentLoaded', initMoveNet);
    </script>
</div>
</body>
</html>
